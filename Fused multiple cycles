import pymc as pm
import numpy as np
import pandas as pd
import arviz as az

# Cross-Cycle Data Setup Example (Multi-Cycle Fusion Mercy)
# Assume long-format DataFrame combining multiple cycles/assessments
# df = pd.concat([pirls_2021, timss_2019, timss_2023, pisa_2022], ignore_index=True)
# Required columns:
# 'y' (harmonized score, e.g., standardized/plausible value mean across assessments)
# 'cycle' (e.g., 'PIRLS2021', 'TIMSS2019', 'TIMSS2023', 'PISA2022' â€” categorical)
# 'country_idx', 'school_idx', 'class_idx', 'teacher_idx' (harmonized IDs across cycles)
# Student covariates: 'gender_centered', 'ses_standardized'
# Teacher covariates: 'teacher_experience_std', 'teacher_qualification_centered'
# New: 'cycle_idx' (integer index for cycles), 'year' (numeric year for trend)

# Preprocessing (harmonization mercy)
cycles = np.unique(df['cycle'])
cycle_to_idx = {c: i for i, c in enumerate(cycles)}
df['cycle_idx'] = df['cycle'].map(cycle_to_idx)
df['year_centered'] = df['year'] - df['year'].mean()  # For linear trend

coords = {
    "cycle": cycles,
    "country": np.unique(df['country_idx']),
    "school": np.unique(df['school_idx']),
    "class": np.unique(df['class_idx']),
    "teacher": np.unique(df['teacher_idx']),
    "obs": np.arange(len(df))
}

with pm.Model(coords=coords) as cross_cycle_fusion_ultramaster_pymc:
    # Global hyperpriors
    mu_global = pm.Normal("mu_global", mu=500, sigma=100)
    
    # Group varying intercepts
    tau_country = pm.HalfCauchy("tau_country", beta=60)
    tau_school = pm.HalfCauchy("tau_school", beta=45)
    tau_class = pm.HalfCauchy("tau_class", beta=35)
    tau_teacher = pm.HalfCauchy("tau_teacher", beta=30)
    
    # Cycle-specific effects (varying intercept + optional trend)
    tau_cycle = pm.HalfCauchy("tau_cycle", beta=50)
    beta_year = pm.Normal("beta_year", mu=0, sigma=20)  # Linear time trend across cycles
    
    sigma_obs = pm.HalfNormal("sigma_obs", sigma=70)
    
    # Non-centered random effects
    z_country = pm.Normal("z_country", mu=0, sigma=1, dims="country")
    z_school = pm.Normal("z_school", mu=0, sigma=1, dims="school")
    z_class = pm.Normal("z_class", mu=0, sigma=1, dims="class")
    z_teacher = pm.Normal("z_teacher", mu=0, sigma=1, dims="teacher")
    z_cycle = pm.Normal("z_cycle", mu=0, sigma=1, dims="cycle")
    
    # Hierarchical means
    mu_country = pm.Deterministic("mu_country", mu_global + z_country * tau_country, dims="country")
    
    mu_school = pm.Deterministic(
        "mu_school",
        mu_country[df['country_idx'].values] + z_school[df['school_idx'].values] * tau_school,
        dims="obs"
    )
    
    mu_class = pm.Deterministic(
        "mu_class",
        mu_school + z_class[df['class_idx'].values] * tau_class,
        dims="obs"
    )
    
    mu_teacher = pm.Deterministic(
        "mu_teacher",
        mu_class + z_teacher[df['teacher_idx'].values] * tau_teacher,
        dims="obs"
    )
    
    mu_cycle = pm.Deterministic(
        "mu_cycle",
        mu_teacher 
        + z_cycle[df['cycle_idx'].values] * tau_cycle
        + beta_year * df['year_centered'].values,
        dims="obs"
    )
    
    # Student-level fixed covariates
    beta_gender = pm.Normal("beta_gender", mu=0, sigma=20)
    beta_ses = pm.Normal("beta_ses", mu=20, sigma=20)
    
    # Teacher-level fixed covariates
    beta_teacher_exp = pm.Normal("beta_teacher_exp", mu=10, sigma=15)
    beta_teacher_qual = pm.Normal("beta_teacher_qual", mu=15, sigma=15)
    
    # Final student predicted mean (cross-cycle harmonized)
    mu_student = pm.Deterministic(
        "mu_student",
        mu_cycle
        + beta_gender * df['gender_centered'].values
        + beta_ses * df['ses_standardized'].values
        + beta_teacher_exp * df['teacher_experience_std'].values
        + beta_teacher_qual * df['teacher_qualification_centered'].values,
        dims="obs"
    )
    
    # Likelihood (harmonized scores)
    y_obs = pm.Normal(
        "y_obs",
        mu=mu_student,
        sigma=sigma_obs,
        observed=df['y'].values,
        dims="obs"
    )
    
    # Sampling (increased for complexity)
    trace = pm.sample(1500, tune=2000, target_accept=0.97, random_seed=42)

# Posterior Predictive Checks
with cross_cycle_fusion_ultramaster_pymc:
    ppc = pm.sample_posterior_predictive(
        trace,
        var_names=["y_obs"],
        extend_inferencedata=True,
        random_seed=42
    )

# LOOCV Validation
loo = az.loo(trace, pointwise=True)
print(loo)

# Cross-Cycle Insights Examples
az.plot_forest(trace, var_names=["z_cycle", "beta_year"], combined=True)  # Cycle effects + trend
az.plot_posterior(trace, var_names=["beta_year"])  # Time trend credibility
